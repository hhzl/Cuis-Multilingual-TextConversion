'From Pharo2.0a of ''18 April 2012'' [Latest update: #20534] on 11 February 2013 at 7:53:31 pm'!Object subclass: #ZnCharacterEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Zinc-Character-Encoding-Core'!!ZnCharacterEncoder commentStamp: '<historical>' prior: 0!I am ZnCharacterEncoder, I encode and decode Character objects to and from a binary stream.I am an abstract class with following protocol:#nextFromStream:#nextPut:toStream:#encodedByteCountFor:The first two are compatible with TextConverter and subclasses.I add some convenience methods:#encodeString:#decodeBytes:#encodedByteCountForString:Contrary to older encoders, I work strictly from strings to bytes and vice versa and I will throw errors instead of silently ignoring them.Part of Zinc HTTP Components.!!ZnCharacterEncoder methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 12/14/2010 11:56'!= anObject	^ self class == anObject class! !!ZnCharacterEncoder methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 4/20/2011 12:19'!hash	^ self class name hash! !!ZnCharacterEncoder methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 12/16/2012 15:17'!decodeBytes: bytes	"Decode bytes and return the resulting string"		| byteStream |	byteStream := bytes readStream.	^ String streamContents: [ :stream |		[ byteStream atEnd ] whileFalse: [			stream nextPut: (self nextFromStream: byteStream) ] ] ! !!ZnCharacterEncoder methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 12/16/2012 15:17'!encodeString: string	"Encode string and return the resulting byte array"		^ ByteArray streamContents: [ :stream |		string do: [ :each | 			self nextPut: each toStream: stream ] ] ! !!ZnCharacterEncoder methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 12/16/2012 15:18'!encodedByteCountForString: string	"Return the exact number of bytes it would take to encode string as a byte array"	^ string 		inject: 0 		into: [ :sum :each |			sum + (self encodedByteCountFor: each) ]! !!ZnCharacterEncoder methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 11/29/2010 21:17'!encodedByteCountFor: character	"Return how many bytes are needed to encode character"		self subclassResponsibility ! !!ZnCharacterEncoder methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 11/29/2010 21:16'!nextFromStream: stream	"Read and return the next character from stream"		self subclassResponsibility ! !!ZnCharacterEncoder methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 11/29/2010 21:16'!nextPut: character toStream: stream	"Write the encoding for character to stream"		self subclassResponsibility ! !!ZnCharacterEncoder methodsFor: 'error handling' stamp: 'SvenVanCaekenberghe 12/16/2012 15:21'!error: message	ZnCharacterEncodingError signal: message! !!ZnCharacterEncoder methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 12/17/2012 14:47'!beLenient	"Don't be strict, which is the default"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ZnCharacterEncoder class	instanceVariableNames: ''!!ZnCharacterEncoder class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/25/2011 11:07'!handlesEncoding: string	"Return true when my instances handle the encoding described by string"		self subclassResponsibility ! !!ZnCharacterEncoder class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 1/25/2011 13:27'!newForEncoding: string	"Return a new character encoder object for an encoding described by string.	Search for a subclass that handles it and delegate (subclassResponsibility).	We default to ZnNullEncoder."		| concreteSubclass encoding |	encoding := string asLowercase.	concreteSubclass := self subclasses 		detect: [ :each | each handlesEncoding: encoding ] 		ifNone: [ ZnNullEncoder ].	^ concreteSubclass newForEncoding: encoding! !