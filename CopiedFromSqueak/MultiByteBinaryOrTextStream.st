'From Squeak4.4 of 31 December 2012 [latest update: #12327] on 6 February 2013 at 10:03:16 pm'!ReadWriteStream subclass: #MultiByteBinaryOrTextStream	instanceVariableNames: 'isBinary converter'	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MultiByteBinaryOrTextStream commentStamp: '<historical>' prior: 0!It is similar to MultiByteFileStream, but works on in memory stream.!!MultiByteBinaryOrTextStream methodsFor: 'accessing' stamp: 'yo 11/11/2002 13:16'!ascii	isBinary := false! !!MultiByteBinaryOrTextStream methodsFor: 'accessing' stamp: 'yo 11/11/2002 13:16'!binary	isBinary := true! !!MultiByteBinaryOrTextStream methodsFor: 'accessing' stamp: 'nk 8/2/2004 17:02'!converter	converter ifNil: [converter := self class defaultConverter].	^ converter! !!MultiByteBinaryOrTextStream methodsFor: 'accessing' stamp: 'yo 8/7/2003 09:12'!converter: aConverter	converter := aConverter.! !!MultiByteBinaryOrTextStream methodsFor: 'accessing' stamp: 'yo 11/11/2002 13:25'!isBinary	^ isBinary! !!MultiByteBinaryOrTextStream methodsFor: 'accessing' stamp: 'yo 11/11/2002 16:33'!text	isBinary := false! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 3/1/2005 06:10'!fileInObjectAndCodeForProject	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			self binary.			refStream := SmartRefStream on: self.			object := refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileInProject.  "reads code and objects, then closes the file"			self binary.			object := SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 3/1/2005 06:46'!fileInProject	self setConverterForCodeForProject.	super fileIn.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 3/1/2005 06:46'!setConverterForCodeForProject	self converter: UTF8TextConverter new.! !!MultiByteBinaryOrTextStream methodsFor: 'converting' stamp: 'yo 11/11/2002 13:16'!asBinaryOrTextStream	^ self! !!MultiByteBinaryOrTextStream methodsFor: 'fileIn/Out' stamp: 'yo 8/17/2004 10:02'!fileIn	self setConverterForCode.	super fileIn.! !!MultiByteBinaryOrTextStream methodsFor: 'fileIn/Out' stamp: 'yo 11/11/2002 16:31'!fileInObjectAndCode	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			self binary.			refStream := SmartRefStream on: self.			object := refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileIn.  "reads code and objects, then closes the file"			self binary.			object := SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!MultiByteBinaryOrTextStream methodsFor: 'fileIn/Out' stamp: 'tak 1/12/2005 13:47'!fileOutClass: extraClass andObject: theObject 	UTF8TextConverter writeBOMOn: self.	^ super fileOutClass: extraClass andObject: theObject! !!MultiByteBinaryOrTextStream methodsFor: 'fileIn/Out' stamp: 'nice 1/18/2010 13:42'!setConverterForCode	| current |	current := converter saveStateOf: self.	self position: 0.	self binary.	((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	converter restoreStateOf: self with: current.	self text.! !!MultiByteBinaryOrTextStream methodsFor: 'fileIn/Out' stamp: 'yo 7/7/2004 09:43'!setEncoderForSourceCodeNamed: streamName	| l |	l := streamName asLowercase."	((l endsWith: FileStream multiCs) or: [		(l endsWith: FileStream multiSt) or: [			(l endsWith: (FileStream multiSt, '.gz')) or: [				(l endsWith: (FileStream multiCs, '.gz'))]]]) ifTrue: [					self converter: UTF8TextConverter new.					^ self.	]."	((l endsWith: FileStream cs) or: [		(l endsWith: FileStream st) or: [			(l endsWith: (FileStream st, '.gz')) or: [				(l endsWith: (FileStream cs, '.gz'))]]]) ifTrue: [					self converter: MacRomanTextConverter new.					^ self.	].	self converter: UTF8TextConverter new.! !!MultiByteBinaryOrTextStream methodsFor: 'properties-setting' stamp: 'yo 11/14/2002 13:49'!setFileTypeToObject	"do nothing.  We don't have a file type"! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 7/30/2004 06:59'!contents	| ret state |	state := converter saveStateOf: self.	ret := self upToEnd.	converter restoreStateOf: self with: state.	^ ret.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 11/11/2002 16:39'!next	| n |	n := self converter nextFromStream: self.	n ifNil: [^ nil].	isBinary and: [n isCharacter ifTrue: [^ n asciiValue]].	^ n.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ar 4/12/2005 17:34'!next: anInteger 	| multiString |	"self halt."	self isBinary ifTrue: [^ (super next: anInteger) asByteArray].	multiString := WideString new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next) ifNotNil: [			multiString at: index put: character		] ifNil: [			multiString := multiString copyFrom: 1 to: index - 1.			^ multiString		]	].	^ multiString.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:08'!next: anInteger putAll: aCollection startingAt: startIndex	(self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [		^super next: anInteger putAll: aCollection startingAt: startIndex ].	^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 12/25/2003 16:05'!nextDelimited: terminator	| out ch pos |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	pos := self position.	self next = terminator ifFalse: [		"absorb initial terminator"		self position: pos.	].	[(ch := self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 11/11/2002 13:24'!nextMatchAll: aColl    | save |    save := converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'nice 3/19/2010 19:05'!nextPut: aCharacter	aCharacter isInteger ifTrue: [^ super nextPut: aCharacter asCharacter].	self converter nextPut: aCharacter toStream: self.	^aCharacter! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'nice 3/19/2010 19:14'!nextPutAll: aCollection	self isBinary ifTrue: [		^ super nextPutAll: aCollection.	].	^aCollection do: [:e | self nextPut: e].! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 11/14/2002 13:54'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 12/25/2003 16:04'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next pos |	self atEnd ifTrue: [^ nil].	pos := self position.	next := self next.	self position: pos.	^ next.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:13'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'nk 7/29/2004 12:02'!reset	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].	self converter. "ensure that we have a converter."! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 11/11/2002 16:17'!skipSeparators	[self atEnd] whileFalse: [		self basicNext isSeparator ifFalse: [			^ self position: self position - 1]]! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 12/25/2003 16:04'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek pos |	[self atEnd] whileFalse: [		pos := self position.		(peek := self next) isSeparator ifFalse: [			self position: pos.			^ peek.		].	].! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'nice 8/27/2010 20:49'!upTo: delim 	| out ch |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	[(ch := self next) == nil] whileFalse: [		(ch = delim) ifTrue: [			^ out contents  "terminator is not doubled; we're done!!"		].		out nextPut: ch.	].	^ out contents.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'yo 11/11/2002 16:17'!upToEnd	| newStream element newCollection |	newCollection := self isBinary				ifTrue: [ByteArray new: 100]				ifFalse: [String new: 100].	newStream := WriteStream on: newCollection.	[(element := self next) notNil]		whileTrue: [newStream nextPut: element].	^ newStream contents! !!MultiByteBinaryOrTextStream methodsFor: 'private' stamp: 'nice 1/18/2010 13:41'!guessConverter	^ (self originalContents includesSubString: #[27 36] asString)		ifTrue: [CompoundTextConverter new]		ifFalse: [self class defaultConverter ]! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 16:01'!basicNext	^ super next ! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'md 10/20/2004 15:32'!basicNext: anInteger	^ super next: anInteger.! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 13:21'!basicNext: n into: aString	^ super next: n into: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'ul 1/31/2011 02:04'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^super next: anInteger putAll: aCollection startingAt: startIndex! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 13:21'!basicNextInto: aString	^ super nextInto: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 13:21'!basicNextPut: char	^ super nextPut: char.! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 13:21'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 13:21'!basicPeek	^ super peek! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 13:21'!basicPosition	^ super position.! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'yo 11/11/2002 13:21'!basicPosition: pos	^ super position: pos.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MultiByteBinaryOrTextStream class	instanceVariableNames: ''!!MultiByteBinaryOrTextStream class methodsFor: 'defaults' stamp: 'yo 2/25/2005 20:04'!defaultConverter	^ Latin1TextConverter new.! !!MultiByteBinaryOrTextStream class methodsFor: 'instance creation' stamp: 'ykoubo 9/28/2003 19:59'!on: aCollection encoding: encodingName 	| aTextConverter |	encodingName isNil		ifTrue: [aTextConverter := TextConverter default]		ifFalse: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self on: aCollection)		converter: aTextConverter! !!MultiByteBinaryOrTextStream class methodsFor: 'instance creation' stamp: 'yo 11/23/2003 20:32'!with: aCollection encoding: encodingName 	| aTextConverter |	encodingName isNil		ifTrue: [aTextConverter := TextConverter default]		ifFalse: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self with: aCollection)		converter: aTextConverter! !