'From Squeak4.4 of 31 December 2012 [latest update: #12327] on 5 February 2013 at 12:04:36 pm'!TextConverter subclass: #UTF8TextConverter	instanceVariableNames: ''	classVariableNames: 'StrictUtf8Conversions'	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!UTF8TextConverter commentStamp: '<historical>' prior: 0!Text converter for UTF-8.  Since the BOM is used to distinguish the MacRoman code and UTF-8 code, BOM is written for UTF-8 by #writeBOMOn: which is called by client.!!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 3/22/2010 08:18'!backFromStream: aStream	aStream position = 0 ifTrue: [ ^nil ].	aStream isBinary ifTrue: [ ^aStream basicBack ].	[ aStream position = 0 or: [ 		(aStream basicBack asciiValue bitXor: 128) >= 64 ] ] whileFalse.	^aStream peek! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 3/17/2010 10:06'!decodeString: aString	aString isByteString ifTrue: [ ^self class decodeByteString: aString ].	^super decodeString: aString! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 3/17/2010 10:07'!encodeString: aString	aString isByteString ifTrue: [ ^self class encodeByteString: aString ].	^super encodeString: aString! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."		^self class errorMalformedInput: aString! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21'!nextFromStream: aStream	| char1 value1 char2 value2 unicode char3 value3 char4 value4 |	aStream isBinary ifTrue: [^ aStream basicNext].	char1 := aStream basicNext.	char1 ifNil:[^ nil].	value1 := char1 asciiValue.	value1 <= 127 ifTrue: [		"1-byte char"		^ char1	].	"at least 2-byte char"	char2 := aStream basicNext.	char2 ifNil:[^self errorMalformedInput: (String with: char1)].	value2 := char2 asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63).	].	"at least 3-byte char"	char3 := aStream basicNext.	char3 ifNil:[^self errorMalformedInput: (String with: char1 with: char2)].	value3 := char3 asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63).	].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte char"		char4 := aStream basicNext.		char4 ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].		value4 := char4 asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63).	].	unicode ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].	unicode > 16r10FFFD ifTrue: [		^self errorMalformedInput: (String with: char1 with: char2 with: char3).	].		unicode = 16rFEFF ifTrue: [^ self nextFromStream: aStream].	^ Unicode value: unicode.! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 5/17/2011 17:25'!nextPut: aCharacter toStream: aStream 		| nBytes mask shift ucs2code |	aStream isBinary ifTrue: [ ^aCharacter storeBinaryOn: aStream ].	ucs2code := aCharacter asUnicode ifNil: [ ^aCharacter ].	ucs2code < 256 ifTrue: [		(latin1Encodings at: ucs2code + 1)			ifNil: [ aStream basicNextPut: aCharacter ]			ifNotNil: [ :encodedString | aStream basicNextPutAll: encodedString ].		^aCharacter ].	nBytes := ucs2code highBit + 3 // 5.	mask := #[128 192 224 240 248 252 254 255] at: nBytes.	shift := nBytes - 1 * -6.	aStream basicNextPut: (Character value: (ucs2code bitShift: shift) + mask).	2 to: nBytes do: [ :i | 		shift := shift + 6.		aStream basicNextPut: (			Character value: ((ucs2code bitShift: shift) bitAnd: 63) + 128) ].	^aCharacter.! !!UTF8TextConverter methodsFor: 'friend' stamp: 'yo 11/8/2002 16:17'!leadingChar	^ self shouldNotImplement! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:12'!nextChunkFromStream: input	"Answer the contents of input, up to the next terminator character. Doubled terminators indicate an embedded terminator character."		self skipSeparatorsFrom: input.	^self 		parseLangTagFor: (			self class decodeByteString: (				String new: 1000 streamContents: [ :stream |					[						stream nextPutAll: (input basicUpTo: $!!).						input basicNext == $!! ]							whileTrue: [ 								stream nextPut: $!! ].					input atEnd ifFalse: [ input skip: -1 ] ]))		fromStream: input! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:11'!nextChunkTextFromStream: input	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."		| chunk position runs |	chunk := self nextChunkFromStream: input.	position := input position.	((self skipSeparatorsAndPeekNextFrom: input) == $] and: [		(input basicNext: 7) = ']style[' ])			ifTrue: [				runs := RunArray scanFrom: (self nextChunkFromStream: input) readStream ]			ifFalse: [				input position: position.				runs := RunArray new: chunk size withAll: #() ].	^Text string: chunk runs: runs! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:09'!parseLangTagFor: aString fromStream: stream	| position |	position := stream position.	"Test for ]lang[ tag"	((self skipSeparatorsAndPeekNextFrom: stream) == $] and: [		(stream basicNext: 6) = ']lang[' ]) ifTrue: [			^stream				decodeString: aString				andRuns: (self nextChunkFromStream: stream) ].	"no tag"	stream position: position.	^aString! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 16:44'!skipSeparatorsAndPeekNextFrom: aStream	"Same as #skipSeparators, but returns the next character after the separators if such exists."	| character |	[ 		((character := aStream basicNext) 			ifNil: [ ^aStream "backwards compatibility, should be nil" ])				isSeparator ] whileTrue.	aStream skip: -1.	^character	! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:04'!skipSeparatorsFrom: aStream	[ (aStream basicNext ifNil: [ ^self ]) isSeparator ] whileTrue.	aStream skip: -1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UTF8TextConverter class	instanceVariableNames: ''!!UTF8TextConverter class methodsFor: 'accessing' stamp: 'tak 1/12/2005 13:22'!writeBOMOn: aStream	"Write Byte Order Mark"	aStream nextPut: 16rEF.	aStream nextPut: 16rBB.	aStream nextPut: 16rBF.! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'yo 12/19/2003 22:01'!encodingNames	^ #('utf-8' 'utf8') copy.! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."	self strictUtf8Conversions ifTrue:[		self error: 'Invalid utf8: ', aString	].	^aString! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions	"Preference setter for strict utf-8 conversions"	<preference: 'Strict utf8 conversions'		category: 'general' "should this be localization?"		description: 'If true, invalid utf-8 input will raise errors. If false, invalid utf-8 input will be allowed to pass through the conversion unchanged'		type: #Boolean>		^StrictUtf8Conversions ifNil:[true]! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions: aBool	"Preference setter for strict utf-8 conversions"	StrictUtf8Conversions := aBool.! !!UTF8TextConverter class methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:11'!decodeByteString: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex byte1 byte2 byte3 byte4 unicode |	lastIndex := 1.	(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0		ifTrue: [ ^aByteString ].	outStream := (String new: aByteString size) writeStream.	[		outStream next: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex.		byte1 := aByteString byteAt: nextIndex.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[	^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63)].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63)].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte4 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte4 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63)].		unicode ifNil: [ ^self errorMalformedInput: aByteString ].		unicode = 16rFEFF ifFalse: [ "Skip byte order mark"			outStream nextPut: (Unicode value: unicode) ].		lastIndex := nextIndex + 1.		(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0 ] whileFalse.	^outStream 		next: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex;		contents! !!UTF8TextConverter class methodsFor: 'conversion' stamp: 'ul 3/17/2010 09:54'!encodeByteString: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex |	lastIndex := 1.	(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0		ifTrue: [ ^aByteString ].	outStream := (String new: aByteString size + 1) writeStream.	[		outStream 			next: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex;			nextPutAll: (latin1Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0 ] whileFalse.	^outStream 		next: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex;		contents! !