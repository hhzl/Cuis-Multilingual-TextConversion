'From Squeak4.4 of 31 December 2012 [latest update: #12327] on 6 February 2013 at 6:43:02 am'!StandardFileStream subclass: #MultiByteFileStream	instanceVariableNames: 'converter lineEndConvention wantsLineEndConversion'	classVariableNames: 'Cr CrLf Lf LineEndDefault LineEndStrings LookAheadCount'	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MultiByteFileStream commentStamp: '<historical>' prior: 0!The central class to access the external file.  The interface of this object is similar to good old StandardFileStream, but internally it asks the converter, which is a sub-instance of TextConverter, and do the text conversion.  It also combined the good old CrLfFileStream.  CrLfFileStream class>>new now returns an instance of MultiByteFileStream.  There are several pitfalls:  * You always have to be careful about the binary/text distinction.  In #text mode, it usually interpret the bytes.  * A few file pointer operations treat the file as uninterpreted byte no matter what.  This means that if you use 'fileStream skip: -1', 'fileStream position: x', etc. in #text mode, the file position can be in the middle of multi byte character.  If you want to implement some function similar to #peek for example, call the saveStateOf: and restoreStateOf: methods to be able to get back to the original state.  * #lineEndConvention: and #wantsLineEndConversion: (and #binary) can cause some puzzling situation because the inst var lineEndConvention and wantsLineEndConversion are mutated.  If you have any suggestions to clean up the protocol, please let me know.!!MultiByteFileStream methodsFor: 'accessing' stamp: 'yo 2/21/2004 02:57'!ascii	super ascii.	self detectLineEndConvention.! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'nice 5/10/2009 00:14'!binary	super binary.	self lineEndConvention: nil! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'ul 1/20/2011 01:42'!converter	^converter ifNil: [		self initializeConverter.		converter ]! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'nice 5/10/2009 00:18'!converter: aConverter	converter := aConverter.	self installLineEndConventionInConverter! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'yo 8/6/2003 11:56'!fileInEncodingName: aString	self converter: (TextConverter newForEncoding: aString).	super fileIn.! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'nk 9/5/2004 12:57'!lineEndConvention	^lineEndConvention! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'nice 11/28/2009 13:06'!lineEndConvention: aSymbol	(lineEndConvention := aSymbol) ifNotNil: [wantsLineEndConversion := true].	self installLineEndConventionInConverter! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/20/2011 01:51'!bareNext	self deprecated: 'Don''t use this method anymore.'.	^converter nextFromStream: self.! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:35'!convertStringFromCr: aString 	| inStream outStream |		self deprecated: 'This method is obsolete and private, don''t use it!!'.	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream := ReadStream on: aString.	outStream := WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:35'!convertStringToCr: aString 	| inStream outStream |		self deprecated: 'This method is obsolete and private, don''t use it!!'.	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].	"lineEndConvention == #crlf"	inStream := ReadStream on: aString.	outStream := WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: 					[outStream nextPut: Cr.					inStream peek = Lf ifTrue: [inStream next]]].	^ outStream contents! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:34'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead state |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	wantsLineEndConversion ifFalse: [self lineEndConvention: nil.					^lineEndConvention].	self closed ifTrue: [self lineEndConvention: LineEndDefault.					^lineEndConvention].	"Default if nothing else found"	numRead := 0.	state := converter saveStateOf: self.	lineEndConvention := nil.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char := self next.			char = Lf				ifTrue: 					[converter restoreStateOf: self with: state.					self lineEndConvention: #lf.					^lineEndConvention].			char = Cr				ifTrue: 					[self peek = Lf						ifTrue: [self lineEndConvention: #crlf]						ifFalse: [self lineEndConvention: #cr].					converter restoreStateOf: self with: state.					^ lineEndConvention].			numRead := numRead + 1].	converter restoreStateOf: self with: state.	self lineEndConvention: LineEndDefault.	^ lineEndConvention! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:35'!doConversion	^wantsLineEndConversion and: [ lineEndConvention notNil ]! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 12/27/2010 04:43'!next: n innerFor: aString	aString size = 0 ifTrue: [^ aString].	"if we just read a CR, and the next character is an LF, then skip the LF"	aString last == Cr ifTrue: [		| state |		state := converter saveStateOf: self.		(converter nextFromStream: self) ifNotNil: [ :peekChar |			peekChar == Lf ifFalse: [				converter restoreStateOf: self with: state ] ] ].	^aString withSqueakLineEndings! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:31'!wantsLineEndConversion	^wantsLineEndConversion! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'yo 8/17/2004 10:03'!fileIn	self setConverterForCode.	super fileIn.! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'ar 7/29/2005 22:33'!fileInObjectAndCodeForProject	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			self binary.			refStream := SmartRefStream on: self.			object := refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileInProject.  "reads code and objects, then closes the file"			self binary.			object := SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'ar 7/29/2005 22:33'!fileInProject	self setConverterForCodeForProject.	super fileIn.! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'tak 1/12/2005 14:48'!fileOutClass: extraClass andObject: theObject 	self binary.	UTF8TextConverter writeBOMOn: self.	self text.	^ super fileOutClass: extraClass andObject: theObject! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'ul 2/5/2010 23:59'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	^converter nextChunkFromStream: self! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'ul 2/7/2010 04:41'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."		^converter nextChunkTextFromStream: self! !!MultiByteFileStream methodsFor: 'open/close' stamp: 'HenrikSperreJohansen 11/20/2009 15:13'!open: fileName forWrite: writeMode 	| result |	result := super open: fileName forWrite: writeMode.	result ifNotNil: [			converter ifNil: [self converter: UTF8TextConverter new].			lineEndConvention ifNil: [ self detectLineEndConvention ]	].	^result! !!MultiByteFileStream methodsFor: 'open/close' stamp: 'nice 5/10/2009 00:18'!reset	super reset.	converter ifNil: [		self converter: UTF8TextConverter new.	].! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 3/22/2010 07:59'!back	^converter backFromStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/30/2011 04:34'!next	| char |	char := converter nextFromStream: self.	"#doConversion is inlined here"	(wantsLineEndConversion and: [ lineEndConvention notNil ]) ifTrue: [		char == Cr ifTrue: [			| state |			state := converter saveStateOf: self.			(converter nextFromStream: self) ifNotNil: [ :secondChar |				secondChar == Lf ifFalse: [					converter restoreStateOf: self with: state ] ].			^Cr ].		char == Lf ifTrue: [			^Cr ] ].	^char.! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/30/2011 04:31'!next: anInteger 	| multiString |	self isBinary ifTrue: [^ super next: anInteger].	multiString := String new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next)			ifNotNil: [ multiString at: index put: character ]			ifNil: [				multiString := multiString copyFrom: 1 to: index - 1.				(wantsLineEndConversion and: [ lineEndConvention notNil ]) "#doConversion is inlined here"					ifFalse: [ ^multiString ].				^self next: anInteger innerFor: multiString ] ].	(wantsLineEndConversion and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifFalse: [ ^multiString ].	multiString := self next: anInteger innerFor: multiString.	(multiString size = anInteger or: [self atEnd]) ifTrue: [ ^ multiString].	^ multiString, (self next: anInteger - multiString size).! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:08'!next: anInteger putAll: aCollection startingAt: startIndex	(self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [		^super next: anInteger putAll: aCollection startingAt: startIndex ].	^converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'yo 2/21/2004 03:26'!nextDelimited: terminator	| out ch save |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	save := converter saveStateOf: self.	self next = terminator ifFalse: [		"absorb initial terminator"		converter restoreStateOf: self with: save.	].	[(ch := self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!MultiByteFileStream methodsFor: 'public' stamp: 'yo 8/28/2002 11:13'!nextMatchAll: aColl    | save |    save := converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 5/17/2011 17:30'!nextPut: aCharacter	aCharacter isInteger ifTrue: [ ^super nextPut: aCharacter ].	^converter nextPut: aCharacter toStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:07'!nextPutAll: aCollection	(self isBinary or: [aCollection class == ByteArray]) ifTrue: [		^ super nextPutAll: aCollection.	].	^converter nextPutAll: aCollection toStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 3/15/2011 13:32'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next state |	state := converter saveStateOf: self.	next := self next.	converter restoreStateOf: self with: state.	^next! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:03'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 3/27/2010 00:04'!skipSeparators	converter skipSeparatorsFrom: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 3/27/2010 16:19'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast. Same as #skipSeparators, but returns the next character after the separators if such exists."		^converter skipSeparatorsAndPeekNextFrom: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 12/4/2009 19:08'!upTo: delimiter	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ ch = delimiter ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!MultiByteFileStream methodsFor: 'public' stamp: 'nice 12/7/2009 08:26'!upToAnyOf: delimiters do: aBlock	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ (delimiters includes: ch) and: [aBlock value: ch. true] ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 12/6/2009 04:18'!upToEnd	^self collectionSpecies		new: self size - self position		streamContents: [ :stream |			| element |			[ (element := self next) == nil ] whileFalse: [				stream nextPut: element ] ]! !!MultiByteFileStream methodsFor: 'remnant' stamp: 'yo 8/28/2002 11:06'!accepts: aSymbol 	^ converter accepts: aSymbol.! !!MultiByteFileStream methodsFor: 'remnant' stamp: 'yo 8/28/2002 11:09'!filterFor: aFileStream	| rw |	name := aFileStream name.	rw := aFileStream isReadOnly not.	aFileStream close.	self open: name forWrite: rw.	^self.! !!MultiByteFileStream methodsFor: 'remnant' stamp: 'ul 1/30/2011 04:35'!wantsLineEndConversion: aBoolean		wantsLineEndConversion := aBoolean.	lineEndConvention ifNil: [ self detectLineEndConvention ]! !!MultiByteFileStream methodsFor: 'private' stamp: 'ul 1/30/2011 04:36'!installLineEndConventionInConverter	converter ifNotNil: [		converter installLineEndConvention: (			(wantsLineEndConversion and: [ lineEndConvention notNil ]) "#doConversion is inlined here"				ifTrue: [ LineEndStrings at: lineEndConvention ]				ifFalse: [ nil ]) ]! !!MultiByteFileStream methodsFor: 'private' stamp: 'ar 4/10/2010 20:48'!requestDropStream: dropIndex	"Needs to install proper converter"	| result |	result := super requestDropStream: dropIndex.	result ifNotNil: [		converter ifNil: [self converter: UTF8TextConverter new].		lineEndConvention ifNil: [ self detectLineEndConvention ]	].	^result! !!MultiByteFileStream methodsFor: 'private' stamp: 'ul 1/20/2011 01:55'!setConverterForCode	| currentPosition |	(SourceFiles at: 2)		ifNotNil: [self fullName = (SourceFiles at: 2) fullName ifTrue: [^ self]].	currentPosition := self position.	self position: 0.	self binary.	((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	self position: currentPosition.	self text.! !!MultiByteFileStream methodsFor: 'private' stamp: 'ar 7/29/2005 22:33'!setConverterForCodeForProject	self converter: UTF8TextConverter new.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'ul 3/22/2010 07:50'!basicBack	self position = 0 ifTrue: [ self errorCantGoBack ].	self skip: -1.	^self basicPeek! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'ul 1/28/2010 02:29'!basicNext: anInteger	^self basicNextInto: (self collectionSpecies new: anInteger)! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:07'!basicNext: n into: aString	^ super next: n into: aString.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'ul 1/31/2011 02:05'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^super next: anInteger putAll: aCollection startingAt: startIndex! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:07'!basicNextInto: aString	^ super nextInto: aString.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:07'!basicNextPut: char	^ super nextPut: char.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:07'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:07'!basicPeek	^ super peek! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicPosition	^ super position.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicPosition: pos	^ super position: pos.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicReadInto: byteArray startingAt: startIndex count: count	^ super readInto: byteArray startingAt: startIndex count: count.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicSetToEnd	^ super setToEnd.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicSkip: n	^ super skip: n.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicUpTo: delim	^ super upTo: delim.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:09'!basicVerbatim: aString	^ super verbatim: aString.! !!MultiByteFileStream methodsFor: 'initialize-release' stamp: 'ul 1/30/2011 04:28'!initialize	super initialize.	wantsLineEndConversion := false.	self initializeConverter! !!MultiByteFileStream methodsFor: 'initialize-release' stamp: 'ul 1/4/2011 07:53'!initializeConverter	self converter: TextConverter defaultSystemConverter! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MultiByteFileStream class	instanceVariableNames: ''!!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'yo 2/21/2004 02:45'!defaultToCR	"MultiByteFileStream defaultToCR"	LineEndDefault := #cr.! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'yo 2/21/2004 02:45'!defaultToCRLF	"MultiByteFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'yo 2/21/2004 02:46'!defaultToLF	"MultiByteFileStream defaultToLF"	LineEndDefault := #lf.! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'nice 11/27/2009 22:01'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current osVersion)					beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'yo 2/21/2004 02:44'!initialize	"MultiByteFileStream initialize"	Cr := Character cr.	Lf := Character lf.	CrLf := String with: Cr with: Lf.	LineEndStrings := Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount := 2048.	Smalltalk addToStartUpList: self.	self startUp.! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'yo 2/21/2004 02:44'!startUp	self guessDefaultLineEndConvention.! !!MultiByteFileStream class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 11:43'!newFrom: aFileStream	| rw n |	n := aFileStream name.	rw := aFileStream isReadOnly not.	aFileStream close.	^self new open: n forWrite: rw.! !!MultiByteFileStream class methodsFor: 'accessing' stamp: 'cmm 10/10/2010 19:17'!lineEndDefault	"Answer the default line-ending convention that will be used by default, which was determined at start-up by looking at platform atributes."	^ LineEndDefault! !!MultiByteFileStream class methodsFor: 'as yet unclassified' stamp: 'ul 1/20/2011 02:18'!newForStdio	"Use crlf as line end convention on windows, lf on all other platforms. Also make sure that the converter is initialized."		| lineEndConvention |	lineEndConvention := self lineEndDefault.	lineEndConvention == #crlf ifFalse: [		lineEndConvention := #lf ].	^self new		lineEndConvention: lineEndConvention;		initializeConverter;		yourself! !MultiByteFileStream initialize!