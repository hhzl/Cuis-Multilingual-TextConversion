'From Squeak4.4 of 31 December 2012 [latest update: #12327] on 6 February 2013 at 6:49:01 am'!Object subclass: #TextConverter	instanceVariableNames: 'latin1Map latin1Encodings'	classVariableNames: ''	poolDictionaries: 'EventSensorConstants'	category: 'Multilingual-TextConversion'!!TextConverter commentStamp: '<historical>' prior: 0!The abstract class for all different type of text converters.  nextFromStream: and nextPut:toStream: are the public accessible methods.  If you are going to make a subclass for a stateful text conversion, you should override restoreStateOf:with: and saveStateOf: along the line of CompoundTextConverter.!!TextConverter methodsFor: 'conversion' stamp: 'ul 3/22/2010 07:47'!backFromStream: aStream	self subclassResponsibility! !!TextConverter methodsFor: 'conversion' stamp: 'ul 3/13/2010 19:35'!decodeString: aString	^String new: aString size streamContents: [ :stream |		| readStream character |		readStream := aString readStream.		[ (character := self nextFromStream: readStream) == nil ]			whileFalse: [ stream nextPut: character ] ]! !!TextConverter methodsFor: 'conversion' stamp: 'ul 3/13/2010 19:32'!encodeString: aString	^String new: aString size streamContents: [ :stream | 		self 			nextPutAll: aString			toStream: stream ]! !!TextConverter methodsFor: 'conversion' stamp: 'ul 8/17/2012 23:22'!next: anInteger putAll: aString startingAt: startIndex toStream: aStream	"Handle fast conversion if ByteString"		| lastIndex nextIndex |	aString class == ByteString ifFalse: [		startIndex to: startIndex + anInteger - 1 do: [ :index |			self nextPut: (aString at: index) toStream: aStream ].		^aString ].	aStream isBinary ifTrue: [		aStream basicNext: anInteger putAll: aString startingAt: startIndex.		^aString ].	lastIndex := startIndex.	[ (nextIndex := ByteString 		findFirstInString: aString		inSet: latin1Map		startingAt: lastIndex) = 0 or: [ anInteger + startIndex <= nextIndex ] ] whileFalse: [			aStream				basicNext: nextIndex - lastIndex putAll: aString startingAt: lastIndex;				basicNextPutAll: (latin1Encodings at: (aString byteAt: nextIndex) + 1).			lastIndex := nextIndex + 1 ].	aStream basicNext: anInteger - lastIndex + startIndex putAll: aString startingAt: lastIndex.	^aString! !!TextConverter methodsFor: 'conversion' stamp: 'yo 8/19/2002 15:27'!nextFromStream: aStream	self subclassResponsibility.! !!TextConverter methodsFor: 'conversion' stamp: 'yo 8/19/2002 15:27'!nextPut: aCharacter toStream: aStream	self subclassResponsibility.! !!TextConverter methodsFor: 'conversion' stamp: 'ul 1/31/2011 01:52'!nextPutAll: aString toStream: aStream	"Handle fast conversion if ByteString"		^self next: aString size putAll: aString startingAt: 1 toStream: aStream! !!TextConverter methodsFor: 'friend' stamp: 'yo 8/19/2002 15:27'!currentCharSize	self subclassResponsibility.! !!TextConverter methodsFor: 'friend' stamp: 'yo 7/29/2003 15:51'!emitSequenceToResetStateIfNeededOn: aStream! !!TextConverter methodsFor: 'friend' stamp: 'yo 2/21/2004 03:26'!restoreStateOf: aStream with: aConverterState	aStream position: aConverterState.! !!TextConverter methodsFor: 'friend' stamp: 'yo 2/21/2004 03:59'!saveStateOf: aStream	^ aStream position.! !!TextConverter methodsFor: 'query' stamp: 'yo 8/19/2002 15:27'!accepts: aSymbol	self subclassResponsibility.! !!TextConverter methodsFor: 'initialize-release' stamp: 'nice 12/8/2009 20:12'!initialize	super initialize.	latin1Map := self class latin1Map.	latin1Encodings := self class latin1Encodings.! !!TextConverter methodsFor: 'initialize-release' stamp: 'ar 10/27/2009 20:32'!installLineEndConvention: lineEndStringOrNil	latin1Map := self class latin1Map.	latin1Encodings := self class latin1Encodings.	lineEndStringOrNil ifNotNil:		[latin1Encodings := latin1Encodings copy.		latin1Encodings at: Character cr asciiValue + 1 put: lineEndStringOrNil.		latin1Map := latin1Map copy.		latin1Map at: Character cr asciiValue + 1 put: 1]! !!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 2/7/2010 04:25'!nextChunkFromStream: input	"Answer the contents of input, up to the next terminator character. Doubled terminators indicate an embedded terminator character."		input skipSeparators.	^self		parseLangTagFor: (			String new: 1000 streamContents: [ :output |				| character state |				[ 					(character := self nextFromStream: input) == nil or: [ 						character == $!! and: [ 							state := self saveStateOf: input.							(self nextFromStream: input) ~~ $!! ] ] ] 					whileFalse: [ output nextPut: character ].				character ifNotNil: [ 					self restoreStateOf: input with: state ] ])		fromStream: input! !!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 2/7/2010 04:39'!nextChunkTextFromStream: input	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."		| chunk state runs |	chunk := self nextChunkFromStream: input.	state := self saveStateOf: input.	(input skipSeparatorsAndPeekNext == $] and: [		(input next: 7) = ']style[' ])			ifTrue: [				runs := RunArray scanFrom: (self nextChunkFromStream: input) readStream ]			ifFalse: [				self restoreStateOf: input with: state.				runs := RunArray new: chunk size withAll: #() ].	^Text string: chunk runs: runs! !!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 2/7/2010 04:24'!parseLangTagFor: aString fromStream: stream	| state |	state := self saveStateOf: stream.	"Test for ]lang[ tag"	(stream skipSeparatorsAndPeekNext == $] and: [		(stream next: 6) = ']lang[' ]) ifTrue: [			^stream				decodeString: aString				andRuns: (self nextChunkFromStream: stream) ].	"no tag"	self restoreStateOf: stream with: state.	^aString			! !!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/26/2010 23:58'!skipSeparatorsAndPeekNextFrom: aStream	"Same as #skipSeparators, but returns the next character after the separators if such exists."	| state character |	[ 		state := self saveStateOf: aStream.		(character := aStream next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		self restoreStateOf: aStream with: state.		^character ].	^aStream	! !!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:02'!skipSeparatorsFrom: aStream	| state character |	[ 		state := self saveStateOf: aStream.		(character := aStream next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		self restoreStateOf: aStream with: state ]	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextConverter class	instanceVariableNames: 'latin1Map latin1Encodings'!!TextConverter class methodsFor: 'instance creation' stamp: 'yo 12/28/2003 00:54'!default	^ UTF8TextConverter new.! !!TextConverter class methodsFor: 'instance creation' stamp: 'yo 7/25/2003 14:08'!defaultConverterClassForEncoding: encodingName	"TextConverter defaultConverterClassForEncoding: 'shift-jis'"	^ self allSubclasses		detect: [:class | class encodingNames includes: encodingName]		ifNone: []! !!TextConverter class methodsFor: 'instance creation' stamp: 'mir 7/20/2004 15:51'!defaultSystemConverter	^LanguageEnvironment defaultSystemConverter! !!TextConverter class methodsFor: 'instance creation' stamp: 'yo 2/21/2004 04:56'!newForEncoding: aString 	| class encoding |	aString ifNil: [^ Latin1TextConverter new].	encoding := aString asLowercase.	class := self allSubclasses				detect: [:each | each encodingNames includes: encoding]				ifNone: [].	class isNil		ifTrue: [^ nil].	^ class new! !!TextConverter class methodsFor: 'utilities' stamp: 'yo 7/5/2004 19:41'!allEncodingNames	"TextConverter allEncodingNames"	| encodingNames |	encodingNames := Set new.	self allSubclasses		do: [:each | 			| names | 			names := each encodingNames.			names notEmpty				ifTrue: [encodingNames add: names first asSymbol]].	^encodingNames! !!TextConverter class methodsFor: 'utilities' stamp: 'yo 8/19/2002 15:28'!encodingNames 	^ #() copy.! !!TextConverter class methodsFor: 'accessing' stamp: 'nice 12/8/2009 23:19'!initializeLatin1MapAndEncodings	"Initialize the latin1Map and latin1Encodings.	These variables ensure that conversions from latin1 ByteString is reasonably fast"		latin1Map := ByteArray new: 256.	latin1Encodings := Array new: 256.	0 to: 255 do:[:i |		| latin1 encoded |		latin1 := String with: (Character value: i).		encoded := (String new: 8) writeStream.		[self new nextPut: latin1 first toStream: encoded] ifError: [].		encoded := encoded contents.		latin1 = encoded ifTrue:[			latin1Map at: i+1 put: 0. "no translation needed"		] ifFalse:[			latin1Map at: i+1 put: 1. "translation needed"			latin1Encodings at: i+1 put: encoded.		].	].! !!TextConverter class methodsFor: 'accessing' stamp: 'nice 5/9/2009 23:35'!latin1Encodings	"Answer an Array mapping latin1 characters to conversion string"	^latin1Encodings ifNil:		[self initializeLatin1MapAndEncodings.		latin1Encodings]! !!TextConverter class methodsFor: 'accessing' stamp: 'nice 5/9/2009 23:34'!latin1Map	"Answer a ByteArray map telling if latin1 characters needs conversion or not"	^latin1Map ifNil:		[self initializeLatin1MapAndEncodings.		latin1Map]! !